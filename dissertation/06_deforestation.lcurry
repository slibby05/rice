We now turn to our second optimization, deforestation.
The goal of this optimization is to remove intermediate data structures.
Often, when writing functional programs, programmes tend to use a pipeline style.
for example, consider the program

> sumPrimes   =  length . filter isPrime . enumFromTo 2

While This style is concise and readable it isn't efficient.
First we create a list of the first |n| integers excluding 1,
then we create a new list of all of the integers that are prime,
finally we sum the values in that list.
It would be much more efficient to compute this sum directly.

> sumPrimes n = go 2 n
>  where  go k n
>         | k >= n     = 0
>         | isPrime k  = 1 + go (k+1) n
>         | otherwise  = go (k+1) n


This pipeline pattern is pervasive in functional programming,
so it's worth understanding and optimizing it.
In particular it would be nice to eliminate the two intermediate lists
created here.
This is the goal of deforestation.

\section{The Original Scheme}
Deforestation has actually gone through several forms throughout it's history.
The original optimization proposed by Phillip Wadler \cite{wadler_deforest}
was very general but it required a complicated algorithm, and it could fail to terminate.
There have been various attempts to improve this algorithm \cite{turchin_supercompiler} and 
\cite{wadler_ferguson_deforest}
that have focused on restricting the form of programs.

An alternative was proposed by Gill in his dissertation \cite{gill_dissertation, shortcut_deforest}
called foldr-build deforestation or short-cut deforestation. 
This approach is much simpler, always terminates, and has a nice correctness proof,
but it comes at the cost of generality.
Foldr-build deforestation only works with functions that produce and consume lists.
Still, lists are common enough in functional languages that this optimization has proven to be effective.

Since then foldr-build deforestation has been extended to stream fusion \cite{steam_fustion}.
While this optimization is able to cover more cases than foldr-build deforestation,
it relies on more advanced compiler technology.

The foldr-build optimization itself is actually very simple.
It relies on an observation about the structure of a list.
All lists in Curry are built up from cons and nil cells.
The list |[1,2,3,4]| is really |1 : 2 : 3 : 4 : []|.
One really common list processing technique is a fold.
A fold takes a binary operation and a starting element, and reduces a list to a single value.
In Curry the |foldr| function is defined as

> foldr :: (a -> b -> b) -> b -> [a] -> b
> foldr f z []      = z
> foldr f z (x:xs)  = x `f` foldr f z xs

As an example, we can define the |sum| function as |sum xs = foldr (+) 0|.
To see what this is really doing we can unroll the recursion.
Suppose we evaluate |foldr (+) 0 [1,2,3,4,5]|, then we have:

> foldr (+) 0 [1,2,3,4,5]
> => 1 + foldr (+) 0 [2,3,4,5]
> => 1 + 2 + foldr (+) 0 [3,4,5]
> => 1 + 2 + 3 + foldr (+) 0 [4,5]
> => 1 + 2 + 3 + 4 + foldr (+) 0 [5]
> => 1 + 2 + 3 + 4 + 5 + foldr (+) 0 []
> => 1 + 2 + 3 + 4 + 5 + 0

But wait, this looks very similar to our construction of a list.

> 1  :  2  :  3  :  4  :  5  :  []
> 1  +  2  +  3  +  4  +  5  +  0

We've just replaced that |:| with |+| and the |[]| with |0|.
If the compiler can find where we will just be replacing |:| with another function,
then we don't need to construct the list.
On its own, this is a very hard problem, but we can help the compiler along.
We just need a standard way to construct a list.
This can be done with the |build| function.

> build :: (forall b (a -> b -> b) -> b -> b) -> [a]
> build g = g (:) []

The |build| function takes a function that constructs a list.
This is a little convoluted at first, but the idea is to 

> upto5 c n = 1 `c` 2 `c` 3 `c` 4 `c` 5 `c` n

> sumPrimes m = length (filter isPrime (enumFromTo 2 m))
> =>
> sumPrimes m =  fold (\_ y -> 1 + y) 0 
>                 (build (\c n -> fold (\x y -> if isPrime x then x `c` y else y) n)
>                  (build enumFromTo_build 2 m))
> =>
> sumPrimes m = fold (\_ y -> 1 + y) 0 
>                 (build (\c n -> (enumFromTo_build 2 x) (\x y -> if isPrime x then x `c` y else y) n))
> =>
> sumPrimes m = enumFromTo_build 2 m (\x y -> if isPrime x then (\_ y -> 1 + y) x y else y) 0
> =>
> sumPrimes m = go 2 m (\x y -> if isPrime x then 1 + y else y) 0
>   where go k m c z =  if k > m 
>                       then z
>                       else c k (go (k+1) m c z)
> =>
> sumPrimes m = go 2 m (\x y -> if isPrime x then 1 + y else y) 0
>   where go k m c z =  if k > m 
>                       then z
>                       else (\x y -> if isPrime x then 1 + y else y) k (go (k+1) m c z)
> =>
> sumPrimes m = go 2 m
>   where go k m =  if k > m 
>                   then z
>                   else (\x y -> if isPrime x then 1 + y else y) k (go (k+1) m c z)
> =>
> sumPrimes m = go 2 m
>   where go k m =  if k > m 
>                   then z
>                   else  if isPrime k 
>                         then 1 + (go (k+1) m c z) 
>                         else (go (k+1) m c z)



\section{super combinator problem}

\section{Solution build\_fold}
> build_fold :: ((c -> b -> b) -> (a -> b -> b)) -> (b -> b) -> [a] -> b
> build_fold mkf mkz xs = foldr (mkf (:)) (mkz []) xs


> build_fold mkf mkz (build g) => build (\c n -> g (mkf c) (mkz n))
> foldr f z (build_fold mkf mkz xs) => foldr (mkf f) (mkz z) xs
> build_fold mkf1 mkz2 (build_fold mkf2 mkz2 xs) => build_fold (mkf1 . mkf2) (mkz1 . mkz2) xs

> length (filter isPrime (enumFromTo 2 n))
> =>
> fold length_fold 0 
>  (build_fold (filter_mkf isPrime) id 
>   (build enumFromTo_build 2 n))
> =>
> fold length_fold 0 
>   (build (mk_build (enumFromTo_build 2 n) (filter_mkf isPrime) id)
> =>
> mk_build (enumFromTo_build 2 n) (filter_mkf isPrime) id length_fold 0 
> =>
> let  f = filter_mkf isPrime length_fold
>      z = id 0
> in enumFromTo_build 2 n f z
> =>
> let f = filter_mkf isPrime length_fold
> in enumFromTo_build 2 n f 0


\section{correctness}
We can show that these rules are valid for a deterministic subset of Curry
using the same reasoning as the original foldr/build rule.

\begin{theorem}
For any deterministic |f|, |z|, |g|, |mkf|, and |mkz|,
the following equations hold.
> build_fold mkf mkz (build g) = build (\c n -> g (mkf c) (mkz n))
> foldr f z (build_fold mkf mkz xs) = foldr (mkf f) (mkz z) xs
> build_fold mkf1 mkz2 (build_fold mkf2 mkz2 xs) = build_fold (mkf1 . mkf2) (mkz1 . mkz2) xs
\end{theorem}

\begin{proof}
Recall that the free theorem for |build| is
> forall (a : A) (forall (b : B) h (f a b) = f' a (h b))
> forall (b : B) h (g_B f b) = g_B' f' (h b)

Now substituting |build_fold mkf mkz| for |h|, |:| for |f| and |mkf :| for |f'|
we have\\
if |build_fold mkf mkz (a : b) = (mkf (:)) a (build_fold mkf mkz b)|\\
then |build_fold mkf mkz (g (:) b) = g (mkf (:)) (build_fold mkf mkz b)|\\
and |build_fold mkf mkz [] = mkz []| by definition.\
This gives us the result\\
> build_fold mkf mkz (build g) = g (mkf (:)) (mkz [])
Finally, working backwards from the definition of |build| we have.
> build_fold mkf mkz (build g) = build (\c n -> g (mkf c) (mkz n))



Again with |foldr|\\
if |forall (a : A) (forall (b : B) b (x op y) = (a x) ot (b y)| and |b u = u'|\\
then |b . fold op u = fold ot u' . (map a)|\\
Here we take |b = build_fold mkf mkz|, |op = f|, and |ot = mkf f| |a = id|\\
then the statment becomes\\
$\ $\\
if |build_fold mkf mkz (f x y) = (mkf f) x (build_fold mkf mkz y)|\\
and |build_fold mkf mkz [] = mkz []|\\
then |build_fold mkf mkz . fold f z = fold (mkf f) (mkz z)|\\
$\ $\\
Since both conditions follow directly from the definition of |build_fold| we are left with
> build_fold mkf mkz . fold f z = fold (mkf f) (mkz z)
Which is exactly what we wanted.
Free theorems are fun!

Finally for |build_fold/build_fold| rule
suppose we have the expression
> foldr f z (build_fold mkf_1 mkz_1 (build_fold mkf_2 mkz_2 xs))
by the previous result we have 
> foldr (mkf_1 f) (mkz_1 z) (build_fold mkf_2 mkz_2 xs)
> => foldr (mkf_2 (mkf_1 f)) (mkz_2 (mkz_1 z)) xs
> => foldr ((mkf_2 . mkf_1) f) ((mkz_2 . mkz_1) z) xs
> => foldr f z (build_fold (mkf_2 . mkf_1) (mkz_2 . mkz_1) xs)
Which establishes our result.
> build_fold mkf_1 mkz_1 (build_fold mkf_2 mkz_2) = build_fold (mkf_2 . mkf_1) (mkz_2 . mkz_1)


% > map_mkc f c x y = f x `c` y
% > concat_mkc f xs z = foldr f z xs
% > (concat . map) f xs
% > (concat . map) (\x -> [x,x+1]) [1,3,5]
% > concat (map (\x -> [x,x+1]) [1,3,5])
% > build_fold concat_mkc id (build_fold (map_mkc (\x -> [x,x+1])) id [1,3,5])
% > build_fold ((map_mkc (\x -> [x,x+1]) . concat_mkc) (id . id) [1,3,5]
% > build_fold ((map_mkc (\x -> [x,x+1]) . concat_mkc) id [1,3,5]
% > (map_mkc (\x -> [x,x+1]) . concat_mkc) (:)
% > map_mkc (\x -> [x,x+1]) (concat_mkc (:))
% > (map_mkc (\x -> [x,x+1]) (concat_mkc (:))) x y
% > (concat_mkc (:)) ((\k -> [k,k+1]) x) y
% > foldr (:) y [x,x+1]

\end{proof}

While this gives us confidence that this is a useful optimization.
Unfortunately, as we've already seen, equations reasoning doesn't always apply in Curry.
In fact, as they are currently stated, it's not surprising that these rules don't hold in Curry.
However, with a few assumptions, we can remedy this problem.
First, we need to rewrite our rules so that the reduced expression is in A-Normal form.

> build_fold mkf mkz (build g) =  let g' = (\c n ->  let  f = mkf c
>                                                         z = mkz n
>                                                    in   g f z)
>                                 in build g'
> foldr f z (build_fold mkf mkz xs) =  let  f' = mkf f
>                                           z' = mkz z
>                                      in   foldr f' z' xs
> build_fold mkf1 mkz2 (build_fold mkf2 mkz2 xs) =  let  mkf = mkf1 . mkf2
>                                                        mkz = mkz1 . mkz2
>                                                   in   build_fold mkf mkz xs

Now we are ready to state our result.
\begin{theorem}
suppose |f|, |z|, |g|, |mkf|, and |mkz| are all functions
who's right had side is an expression in A-Normal form,
then the following reductions are valid.
> build_fold mkf mkz (build g) =  let g' = (\c n ->  let  f = mkf c
>                                                         z = mkz n
>                                                    in   g f z)
>                                 in build g'
> foldr f z (build_fold mkf mkz xs) =  let  f' = mkf f
>                                           z' = mkz z
>                                      in   foldr f' z' xs
> build_fold mkf1 mkz2 (build_fold mkf2 mkz2 xs) =  let  mkf = mkf1 . mkf2
>                                                        mkz = mkz1 . mkz2
>                                                   in   build_fold mkf mkz xs

\end{theorem}

\begin{proof}
First recall that any reduction on a term in A-Normal for produces another term in A-Normal form.
\end{proof}
