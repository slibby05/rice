
import System
import GetOpt
import List
import Either (partitionEithers)

import FlatCurry.Goodies
import FlatCurry.Types
import FlatCurry.Pretty as FP
import FlatCurry.Files
import Directory

import Control.SetFunctions

import FlatUtils.Normalize
import FlatUtils.DataTable as DT

import Optimize.Unboxing

import Text.Pretty

import Compile.ToICurry
import Compile.ToC
import Compile.ToH
import ICurry.Pretty as IP

-- This does the same thing as main, it just lets me run it from Pakcs
run :: String -> IO ()
run file = do (fcys,ofcys) <- readfcy_opt_imports file
              putStrLn "\n\nFLAT CURRY\n\n"
              let dt = foldr DT.fillTable DT.empty (ofcys++fcys)
              putStrLn "\n\nFilled data Table\n\n"
              putStrLn (DT.showTable dt)
              putStrLn $ pPrint $ FP.ppProg FP.defaultOptions $ last fcys

              let u_fcy = boxProg (last fcys)
              print u_fcy
              putStrLn "\n\nUNBOXED FLAT CURRY\n\n"
              putStrLn $ pPrint $ FP.ppProg FP.defaultOptions u_fcy
              let c_fcy = transform dt u_fcy
              putStrLn "\n\nTRANSFORMED FLAT CURRY\n\n"
              putStrLn $ pPrint $ FP.ppProg FP.defaultOptions c_fcy

main :: IO ()
main = do
    args <- getArgs
    let (opts, files, errors') = getOpt RequireOrder optDescrs args
    let errors = if length files < 1
                    then "Missing input file" : errors'
                    else errors'
    if not $ null errors
      then
        mapM_ putStrLn errors
      else do

        (fcys,ofcys) <- readfcy_opt_imports $ head files
        putStrLn "\n\nFLAT CURRY\n\n"
        let dt = foldr DT.fillTable DT.empty (ofcys++fcys)
        putStrLn "\n\nFilled data Table\n\n"
        putStrLn (DT.showTable dt)
        writeOpt SFlat opts (FP.ppProg FP.defaultOptions) (last fcys)
        --mapM_ (writeOpt SFlat opts (FP.ppProg defaultOptions)) fcys

        let u_fcy = boxProg (last fcys)
        print u_fcy
        putStrLn "\n\nUNBOXED FLAT CURRY\n\n"
        putStrLn $ pPrint $ FP.ppProg FP.defaultOptions u_fcy
        let c_fcy = transform dt u_fcy
        putStrLn "\n\nTRANSFORMED FLAT CURRY\n\n"
        writeOpt STransformed opts (FP.ppProg FP.defaultOptions) c_fcy

        let icurry = toICurry c_fcy
        putStrLn "\n\nICURRY\n\n"
        --print icurry
        writeOpt SICurry opts ppIProg icurry

        putStrLn "\n\nC\n\n"
        writeCOpt opts toHeader (iname icurry ++".h") icurry
        writeCOpt opts toSource (iname icurry ++".c") icurry
 where 
  writeOpt :: (Show a) => FileType -> [(Maybe String, FileType)] -> (a -> Doc) -> a -> IO ()
  writeOpt opt opts human prog = 
      case find ((==opt) . snd) opts of
           Nothing             -> return ()
           (Just (Nothing, _)) -> putStrLn (pPrint (human prog))
           (Just (Just y, _))  -> writeFile y (pPrint (human prog))
  writeCOpt :: [(Maybe String, FileType)] -> (IProg -> (String -> IO ()) -> (String -> IO ()) -> IO ()) -> String -> IProg -> IO ()
  writeCOpt opts writer name prog = 
      case find ((==SC) . snd) opts of
           Nothing             -> return ()
           (Just (Nothing, _)) -> writer prog putStr putStr
           (Just (Just y, _))  -> writer prog (writeFile name) (appendFile name)

--------------------------------------------------------------------
-- Code for reading files
--
-- Since I need to read and write my own FlatCurry and ICurry files
-- I need to know a few things.
-- For each imported module
-- Have I compiled this module to C? (I don't need to do anything)
-- Have I compiled it to ICurry?
-- Have I optimized the FlatCurry?
-- Am I forcing a recompile anyway?
--
-- I start with a single file that I'm reading in.
-- Then I need to read in all of the imports.
-- I can't use readFlatCurryWithImports, because that will read in 
-- the flatCurry files that were generated by pakcs
-- I would need to re-optimize them
--
-- I will store the all flatcurry programs in ~/.rice/*.fcy
-- All Icurry programs in ~/.rice/*.icy
-- all C programs in ~/.rice/*.c
--
-- This definitely opens me up to name conflicts,
-- and I also don't like using the home directory like this,
-- but the alternative is to store things in local directories
-- and I have no idea how to get that to work correctly.
-- I know gcc useing INCLUDE, PATH, and LD_LIBRARY_PATH to handle this,
-- but I really don't want to deal with environment variables.
--
--
-- So, I read in the FlatCurry version of the program
-- The assumption is that if they're compiling a program, then it has changed,
-- so it needs to be re-compiled
-- Then for each import i
--  If i has an optimized version, read that in
--  if i doesn't have an optimized version, then read in the flatCurry
--  read in all imports of i
--
--
-- After calling readfcy_opt_imports we get a couple of nice properties
-- in the (fcys,opts) tuple we get out we know that
-- 1. all programs in the fcy list haven't been optimized
-- 2. all programs in the opts list have been optimized
-- 3. all imports of an optimized program are optimized
-- 4. fcys is in reverse sorted order
--    if a imports b, then b comes before a in the list
--------------------------------------------------------------------



-- reads a flatCurry file, where some of the imports may have already been optimized
-- We take a string of a program to read
-- we return two lists of programs (fcy, opts)
-- fcy is the normal flatcurry programs that still need to be optimized
-- opts is the programs that have already been optimized
--
-- TODO: add timestamp checking to see if we need to re-optimize a program
readfcy_opt_imports :: String -> IO ([Prog], [Prog])
readfcy_opt_imports file = 
 do rootfcy <- readFlatCurry file
    let imps = getImports rootfcy
    read_import imps ([rootfcy],[]) imps 

getImports :: Prog -> [String]
getImports (Prog _ is _ _ _) = is

-- This is a simple loop to read all of the imports
-- for each import check to see if it's been optimized
-- if it hasn't, the read the flat-curry file
-- Now, we get all of the imports we haven't seen before
-- and we add those to the list of imports
-- We're basically doing a breadth first search of the import graph.
read_import :: [String] -> ([Prog],[Prog]) -> [String] -> IO ([Prog],[Prog])
read_import []         ps          _    = return ps
read_import (imp:imps) (fcys,opts) seen =
 do opt <- try_readopt imp
    case opt of
        Nothing   -> do prog <- readFlatCurry imp
                        let addedImps = newImps prog
                        read_import (imps++addedImps) (prog:fcys, opts) (addedImps++seen)

        Just prog -> do let addedImps = newImps prog
                        read_import (imps++addedImps) (fcys, prog:opts) (addedImps++seen)

  where notSeen = not . (`elem` seen)
        newImps = filter notSeen . getImports

-- tries to read an optimized program from the ~/.rice directory
-- if this file doesn't exist, then we haven't optimized it yet
-- returns Just the optimize program if it exists
-- otherwise it returns Nothing
try_readopt :: String -> IO (Maybe Prog)
try_readopt name = do let file = "~/.rice/" ++ name ++ ".opt"
                      opt <- doesFileExist file
                      if opt then readFlatCurryFile file >>= return . Just 
                             else return Nothing
--------------------------------------------------------------------
-- Code for handling options
--------------------------------------------------------------------

data FileType = SFlat | STransformed | SICurry | SC
 deriving(Show, Eq)

optDescrs :: [OptDescr (Maybe String, FileType)]
optDescrs = [
  Option "f" [] (OptArg (\x-> (x,SFlat)) "FLATCURRY")
                "write flatcurry to file",
  Option "t" [] (OptArg (\x-> (x,STransformed)) "TRANSFORMED")
                "write transformed flatcurry to file",
  Option "i" [] (OptArg (\x-> (x,SICurry)) "ICURRY")
                "write icurry to file",
  Option "c" [] (OptArg (\x-> (x,SC)) "C")
                "write C to file"]

