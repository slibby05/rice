interface tables where {
import Prelude;
f 1 :: [a] -> a;
main 0 :: (Prelude.Enum a, Prelude.Num a) => a;
hiding class Prelude.Enum a;
hiding class Prelude.Num a;
instance Prelude.Enum () {
  enumFromThenTo 3;
  enumFromTo 2;
  enumFromThen 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
} {-# MODULE Prelude #-};
instance Prelude.Enum Prelude.Bool {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
} {-# MODULE Prelude #-};
instance Prelude.Enum Prelude.Char {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 0;
  toEnum 0;
  pred 1;
  succ 1
} {-# MODULE Prelude #-};
instance Prelude.Enum Prelude.Int {
  enumFromThenTo 0;
  enumFromThen 0;
  enumFromTo 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
} {-# MODULE Prelude #-};
instance Prelude.Enum Prelude.Ordering {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
} {-# MODULE Prelude #-};
instance Prelude.Num Prelude.Float {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
} {-# MODULE Prelude #-};
instance Prelude.Num Prelude.Int {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
} {-# MODULE Prelude #-};
hiding data Prelude.Bool;
hiding data Prelude.Char;
hiding data Prelude.Int;
hiding data Prelude.Ordering;
hiding data Prelude.Float
}