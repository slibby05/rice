
import Prelude hiding (lookup)
import System
import List (inits, (\\), elemIndex)
import FlatCurry.Types
import Text.Pretty
import FlatCurry.Pretty as FP
import FlatCurry.Goodies (progFuncs, funcName, progTypes, branchExpr,
                          updProgFuncs, isExternal, updQNamesInTypeExpr, updQNamesInRule)
import List (splitOn)
import FlatCurry.Files  (writeFlatCurryFile, readFlatCurry, readFlatCurryFile)
import FlatUtils.FlatUtils (primType,primCon)
import Data.Map (Map(..), lookup, fromList, member)
import Maybe (fromJust)

readPrelude :: IO Prog
readPrelude = do home <- getEnviron "HOME"
                 prelude <- readFlatCurry "Prelude"
                 prim <- readFlatCurryFile (home++"/.rice/.curry/prim.fcy")
                 let pprim = mergePrelude prelude prim
                 replace <- readFlatCurryFile (home++"/.rice/.curry/replace.fcy")
                 let preplace = (mergePrelude pprim replace)
                 deforest <- readFlatCurryFile (home++"/.rice/.curry/deforestation.fcy")
                 return (mergePrelude preplace deforest)

run :: IO ()
run = do start <- readPrelude
         mapM_ writePart (splitPrelude start splitMap)

check :: IO ()
check = do start <- readPrelude
           let m = splitMap
           mapM_ (checkAfter m) (progFuncs start)

showPrelude :: IO ()
showPrelude = do start <- readPrelude
                 putStrLn $ pPrint $ FP.ppProg FP.defaultOptions start

---------------------------------------------------------------------

checkAfter :: Map String String -> FuncDecl -> IO ()
checkAfter m f = if member fn m
                 then case filter (less m fn) (calls f) of
                           [] -> return ()
                           rs -> do mapM_ (\r -> putStrLn (fn ++ ":" ++ (m!fn) ++
                                                           " calls " ++ r ++ ":" ++ (m!r))) rs
                 else return ()
 where fn = snd (funcName f)

calls :: FuncDecl -> [String]
calls (Func _ _ _ _ (External _)) = []
calls (Func _ _ _ _ (Rule _ b))   = callsExp b

callsExp :: Expr -> [String]
callsExp (Var _) = []
callsExp (Lit _) = []
callsExp (Comb FuncCall (_, n) es) = n : concatMap callsExp es
callsExp (Comb (FuncPartCall _) (_, n) es) = n : concatMap callsExp es
callsExp (Comb ConsCall (_, _) es) = concatMap callsExp es
callsExp (Comb (ConsPartCall _) (_, _) es) = concatMap callsExp es
callsExp (Let vs e) = concatMap callsExp (e : map snd vs)
callsExp (Free _ e) = callsExp e
callsExp (Or e1 e2) = concatMap callsExp [e1,e2]
callsExp (Case _ e bs) = concatMap callsExp (e : map branchExpr bs)
callsExp (Typed e _) = callsExp e

writePart :: Prog -> IO ()
writePart p@(Prog n _ _ _ _) = do home <- getEnviron "HOME"
                                  putStrLn $ pPrint $ FP.ppProg FP.defaultOptions p
                                  writeFlatCurryFile (home++"/.rice/.curry/"++n++".fcy") p

splitPrelude :: Prog -> Map String String -> [Prog]
splitPrelude p pm = let fs = [(f, pm ! snd (funcName f)) | f <- progFuncs p, 
                                                           snd (funcName f) `member` pm]
                        modFs = foldr addToList [[],[],[],[],[],[],[],[]] fs
                        is = inits mods
                     in zipWith3 makeModule mods is modFs
 where makeModule n is fs = if n == "PreludeBase" 
                            then Prog n is (progTypes p) fs []
                            else Prog n is [] fs []

       addToList (x,"PreludeBase")    [b,c,n,l,s,r,m,t] = [x:b,c,n,l,s,r,m,t]
       addToList (x,"PreludeCompare") [b,c,n,l,s,r,m,t] = [b,x:c,n,l,s,r,m,t]
       addToList (x,"PreludeNum")     [b,c,n,l,s,r,m,t] = [b,c,x:n,l,s,r,m,t]
       addToList (x,"PreludeList")    [b,c,n,l,s,r,m,t] = [b,c,n,x:l,s,r,m,t]
       addToList (x,"PreludeString")  [b,c,n,l,s,r,m,t] = [b,c,n,l,x:s,r,m,t]
       addToList (x,"PreludeRead")    [b,c,n,l,s,r,m,t] = [b,c,n,l,s,x:r,m,t]
       addToList (x,"PreludeMonad")   [b,c,n,l,s,r,m,t] = [b,c,n,l,s,r,x:m,t]
       addToList (x,"PreludeTuple")   [b,c,n,l,s,r,m,t] = [b,c,n,l,s,r,m,x:t]

       mods = ["PreludeBase", "PreludeCompare", "PreludeNum",
               "PreludeList", "PreludeString", "PreludeRead",
               "PreludeMonad", "PreludeTuple"]
splitMap :: Map String String
splitMap = fromList $ concatMap makeTuples splits
 where makeTuples (file,funs) = map (\f -> (f,file)) funs


(!) :: Map String String -> String -> String
m ! k = if k == "apply" then "PreludeBase"
        else case lookup k m of
                  Nothing -> error ("couldn't find function " ++ k)
                  Just v  -> v

less :: Map String String -> String -> String -> Bool
less m a b = val (m!a) < val (m!b)
 where
  val :: String -> Int
  val x = fromJust (elemIndex x mods)
  mods = ["PreludeBase", "PreludeCompare", "PreludeNum",
          "PreludeList", "PreludeString", "PreludeRead",
          "PreludeMonad", "PreludeTuple"]

---------------------------------------------------------------------

mergePrelude :: Prog -> Prog -> Prog
mergePrelude prelude prim = updProgFuncs (const (preludeFuns++primFuns)) prelude
 where primFuns      = [makePrim f | f <- progFuncs prim,    not (isExternal f)]
       preludeFuns   = [f          | f <- progFuncs prelude, not (funcName f `elem` primNames)]
       primNames     = map (updName . funcName) primFuns
       makePrim (Func n a v t r) = Func (updName n) a v (updType t) (updRule r)

updType :: TypeExpr -> TypeExpr
updType t = updQNamesInTypeExpr toPrimType t
 where toPrimType n  = case n of
                          ("prim","C")      -> primType "char"
                          ("prim","I")      -> primType "int"
                          ("prim","F")      -> primType "float"
                          (_,x)             -> ("Prelude", repType x)
updRule :: Rule -> Rule
updRule r = updQNamesInRule primRule r
 where primRule n  = case n of
                          ("prim","C")               -> primCon "char"
                          ("prim","I")               -> primCon "int"
                          ("prim","F")               -> primCon "float"
                          (_,x)                      -> ("Prelude",removeRep x)

repType :: String -> String
repType typ = case typ of
                   "RepBool"   -> "Bool"
                   "RepInt"    -> "Int"
                   "RepFloat"  -> "Float"
                   "RepChar"   -> "Char"
                   "RepList"   -> "[]"
                   "RepUnit"   -> "()"
                   "RepT2"     -> "(,)"
                   "RepT3"     -> "(,,)"
                   "RepT4"     -> "(,,,)"
                   "RepT5"     -> "(,,,,)"
                   "RepT6"     -> "(,,,,,)"
                   "RepT7"     -> "(,,,,,,)"
                   _           -> typ

updName :: QName -> QName
updName n = case n of
                 ("replace","def_Ord_LtEq") -> ("Prelude","_def#<=#Prelude.Ord")
                 (_,f)                      -> ("Prelude",removeRep f)

removeRep :: String -> String
removeRep x = case splitOn "replace." x of
                   [a]        -> a
                   [inst,typ] -> case typ of
                                      "RepList"  -> inst++"[]"
                                      "RepUnit"  -> inst++"()"
                                      "RepT2"    -> inst++"(,)"
                                      "RepT3"    -> inst++"(,,)"
                                      "RepT4"    -> inst++"(,,,)"
                                      "RepT5"    -> inst++"(,,,,)"
                                      "RepT6"    -> inst++"(,,,,,)"
                                      "RepT7"    -> inst++"(,,,,,,)"
                                      "RepInt"   -> inst++"Prelude.Int"
                                      "RepFloat" -> inst++"Prelude.Float"
                                      "RepChar"  -> inst++"Prelude.Char"
                                      "RepBool"  -> inst++"Prelude.Bool"
                                      _          -> inst++"Prelude."++typ

---------------------------------------------------------------------

splits :: [(String,[String])]
splits = [("PreludeBase",    preludeBase),
          ("PreludeCompare", preludeCompare),
          ("PreludeNum",     preludeNum),
          ("PreludeList",    preludeList),
          ("PreludeString",  preludeString),
          ("PreludeRead",    preludeRead),
          ("PreludeMonad",   preludeMonad),
          ("PreludeTuple",   preludeTuple)]

preludeBase :: [String]
preludeBase = ["$",
               "$!",
               "$!!",
               "$#",
               "$##",
               "&&",
               ".",
               "=:<<=",
               "=:<=",
               "=:=",
               ">>=$",
               "?",
               ".._#lambda279",
               "asTypeOf",
               "catch",
               "const",
               "ensureNotFree",
               "ensureNotFree",
               "ensureSpine",
               "failed",
               "failure",
               "flip",
               "fst",
               "getChar",
               "groundNormalForm",
               "head",
               "id",
               "ifVar",
               "letrec",
               "normalForm",
               "not",
               "otherwise",
               "primAddFloat",
               "primSubFloat",
               "primMulFloat",
               "primDivFloat",
               "primAddInt",
               "primSubInt",
               "primMulInt",
               "primDivInt",
               "primModInt",
               "primQuotInt",
               "primRemInt",
               "primChr",
               "primEqChar",
               "primEqFloat",
               "primEqFloat",
               "primEqInt",
               "primI2F",
               "primLtEqChar",
               "primLtEqFloat",
               "primLtEqFloat",
               "primLtEqInt",
               "primNegateFloat",
               "primOrd",
               "ltEqChar",
               "ltEqFloat",
               "ltEqInt",
               "eqFloat",
               "prim_appendFile",
               "appendFile",
               "prim_error",
               "error",
               "prim_putChar",
               "putChar",
               "prim_readFile",
               "readFile",
               "prim_writeFile",
               "writeFile",
               "returnIO",
               "seq",
               "snd",
               "tail",
               "until",
               "||",
               "chr",
               "eqChar",
               "eqInt",
               "ord",
               "cond",
               "appPrec",
               "appPrec1",
               "ensureSpine.ensureList.20",
               "if_then_else",
               "solve",
               "success",
               "unknown",
               "&",
               "&>",
               "foldr",
               "build",
               "build_fold",
               "loop",
               "mk_build",
               "PEVAL"]

preludeCompare :: [String]
preludeCompare = ["/=",
                  "<",
                  ">",
                  "<=",
                  "==",
                  ">=",
                  "_def#==#Prelude.Eq",
                  "_def#/=#Prelude.Eq",
                  "_super#Prelude.Ord#Prelude.Eq",
                  "_def#<#Prelude.Ord",
                  "_def#<=#Prelude.Ord",
                  "_def#>#Prelude.Ord",
                  "_def#>=#Prelude.Ord",
                  "_def#compare#Prelude.Ord",
                  "_def#max#Prelude.Ord",
                  "_def#min#Prelude.Ord",
                  "max",
                  "min",
                  "_impl#<=#Prelude.Ord#Prelude.Bool",
                  "_inst#Prelude.Ord#Prelude.Char",
                  "_impl#min#Prelude.Ord#Prelude.Char",
                  "_inst#Prelude.Ord#Prelude.Int",
                  "_impl#min#Prelude.Ord#Prelude.Int",
                  "_inst#Prelude.Ord#Prelude.Float",
                  "_impl#min#Prelude.Ord#Prelude.Float",
                  "_inst#Prelude.Ord#Prelude.Bool",
                  "_impl#min#Prelude.Ord#Prelude.Bool",
                  "_inst#Prelude.Ord#Prelude.Ordering",
                  "_impl#min#Prelude.Ord#Prelude.Ordering",
                  "_inst#Prelude.Ord#Prelude.Maybe",
                  "_impl#min#Prelude.Ord#Prelude.Maybe",
                  "_inst#Prelude.Ord#Prelude.Either",
                  "_impl#min#Prelude.Ord#Prelude.Either",
                  "_impl#<=#Prelude.Ord#Prelude.Char",
                  "_impl#<=#Prelude.Ord#Prelude.Either",
                  "_impl#<=#Prelude.Ord#Prelude.Maybe",
                  "_impl#<=#Prelude.Ord#Prelude.Ordering",
                  "_impl#<=#Prelude.Ord#Prelude.Float",
                  "_impl#<=#Prelude.Ord#Prelude.Int",
                  "_impl#==#Prelude.Eq#Prelude.Bool",
                  "_impl#==#Prelude.Eq#Prelude.Char",
                  "_impl#==#Prelude.Eq#Prelude.Either",
                  "_impl#==#Prelude.Eq#Prelude.Maybe",
                  "_impl#==#Prelude.Eq#Prelude.Ordering",
                  "_impl#max#Prelude.Ord#Prelude.Bool",
                  "_impl#==#Prelude.Eq#Prelude.Float",
                  "_impl#==#Prelude.Eq#Prelude.Int",
                  "_impl#max#Prelude.Ord#Prelude.Either",
                  "_impl#max#Prelude.Ord#Prelude.Maybe",
                  "_impl#max#Prelude.Ord#Prelude.Ordering",
                  "_impl#max#Prelude.Ord#Prelude.Char",
                  "_impl#max#Prelude.Ord#Prelude.Float",
                  "_impl#max#Prelude.Ord#Prelude.Int",
                  "_inst#Prelude.Eq#Prelude.Char",
                  "_inst#Prelude.Eq#Prelude.Bool",
                  "_inst#Prelude.Eq#Prelude.Either",
                  "_inst#Prelude.Eq#Prelude.Maybe",
                  "_inst#Prelude.Eq#Prelude.Ordering",
                  "compare",
                  "_inst#Prelude.Eq#Prelude.Float",
                  "_inst#Prelude.Eq#Prelude.Int",
                  "_impl#/=#Prelude.Eq#Prelude.Bool",
                  "_impl#/=#Prelude.Eq#Prelude.Char",
                  "_impl#/=#Prelude.Eq#Prelude.Either",
                  "_impl#/=#Prelude.Eq#Prelude.Maybe",
                  "_impl#/=#Prelude.Eq#Prelude.Ordering",
                  "_impl#/=#Prelude.Eq#Prelude.Float",
                  "_impl#/=#Prelude.Eq#Prelude.Int",
                  "_impl#<#Prelude.Ord#Prelude.Bool",
                  "_impl#<#Prelude.Ord#Prelude.Char",
                  "_impl#<#Prelude.Ord#Prelude.Either",
                  "_impl#<#Prelude.Ord#Prelude.Float",
                  "_impl#<#Prelude.Ord#Prelude.Int",
                  "_impl#<#Prelude.Ord#Prelude.Maybe",
                  "_impl#<#Prelude.Ord#Prelude.Ordering",
                  "_impl#>#Prelude.Ord#Prelude.Bool",
                  "_impl#>#Prelude.Ord#Prelude.Char",
                  "_impl#>#Prelude.Ord#Prelude.Either",
                  "_impl#>#Prelude.Ord#Prelude.Float",
                  "_impl#>#Prelude.Ord#Prelude.Int",
                  "_impl#>#Prelude.Ord#Prelude.Maybe",
                  "_impl#>#Prelude.Ord#Prelude.Ordering",
                  "_impl#>=#Prelude.Ord#Prelude.Bool",
                  "_impl#>=#Prelude.Ord#Prelude.Char",
                  "_impl#>=#Prelude.Ord#Prelude.Either",
                  "_impl#>=#Prelude.Ord#Prelude.Float",
                  "_impl#>=#Prelude.Ord#Prelude.Int",
                  "_impl#>=#Prelude.Ord#Prelude.Maybe",
                  "_impl#>=#Prelude.Ord#Prelude.Ordering",
                  "_impl#compare#Prelude.Ord#Prelude.Bool",
                  "_impl#compare#Prelude.Ord#Prelude.Char",
                  "_impl#compare#Prelude.Ord#Prelude.Either",
                  "_impl#compare#Prelude.Ord#Prelude.Float",
                  "_impl#compare#Prelude.Ord#Prelude.Int",
                  "_impl#compare#Prelude.Ord#Prelude.Maybe",
                  "_impl#compare#Prelude.Ord#Prelude.Ordering"]

preludeNum :: [String]
preludeNum = ["*",
              "*$",
              "*.",
              "+",
              "+$",
              "+.",
              "-",
              "-$",
              "-.",
              "/",
              "/.",
              "_super#Prelude.Fractional#Prelude.Num",
              "_super#Prelude.Real#Prelude.Num",
              "_super#Prelude.Real#Prelude.Ord",
              "_def#*#Prelude.Num",
              "_def#+#Prelude.Num",
              "_def#-#Prelude.Num",
              "_def#/#Prelude.Fractional",
              "_def#abs#Prelude.Num",
              "_def#div#Prelude.Integral",
              "_def#div#Prelude.Integral._#selFP2#q",
              "_def#divMod#Prelude.Integral",
              "_def#fromFloat#Prelude.Fractional",
              "_def#fromInt#Prelude.Num",
              "_def#mod#Prelude.Integral",
              "_def#mod#Prelude.Integral._#selFP4#r",
              "_def#negate#Prelude.Num",
              "_def#quot#Prelude.Integral",
              "_def#quot#Prelude.Integral._#selFP6#q",
              "_def#quotRem#Prelude.Integral",
              "_def#recip#Prelude.Fractional",
              "_def#rem#Prelude.Integral",
              "_def#rem#Prelude.Integral._#selFP8#r",
              "_def#signum#Prelude.Num",
              "_impl#*#Prelude.Num#Prelude.Float",
              "_impl#*#Prelude.Num#Prelude.Int",
              "_impl#+#Prelude.Num#Prelude.Float",
              "_impl#+#Prelude.Num#Prelude.Int",
              "_impl#-#Prelude.Num#Prelude.Float",
              "_impl#-#Prelude.Num#Prelude.Int",
              "_impl#/#Prelude.Fractional#Prelude.Float",
              "_impl#abs#Prelude.Num#Prelude.Float",
              "_impl#abs#Prelude.Num#Prelude.Int",
              "_impl#divMod#Prelude.Integral#Prelude.Int",
              "_impl#fromFloat#Prelude.Fractional#Prelude.Float",
              "_impl#fromInt#Prelude.Num#Prelude.Float",
              "_impl#fromInt#Prelude.Num#Prelude.Int",
              "_impl#negate#Prelude.Num#Prelude.Float",
              "_impl#negate#Prelude.Num#Prelude.Int",
              "_impl#quotRem#Prelude.Integral#Prelude.Int",
              "_impl#recip#Prelude.Fractional#Prelude.Float",
              "_impl#rem#Prelude.Integral#Prelude.Int",
              "_impl#signum#Prelude.Num#Prelude.Float",
              "_impl#signum#Prelude.Num#Prelude.Int",
              "_inst#Prelude.Fractional#Prelude.Float",
              "_inst#Prelude.Num#Prelude.Float",
              "_inst#Prelude.Num#Prelude.Int",
              "_inst#Prelude.Real#Prelude.Float",
              "_inst#Prelude.Real#Prelude.Int",
              "divMod",
              "divMod_",
              "div_",
              "fromInt",
              "i2f",
              "mod_",
              "negate",
              "negateFloat",
              "negate_",
              "pow",
              "powaux",
              "square",
              "halve",
              "quotRem",
              "quotRem_",
              "quot_",
              "recip",
              "rem_",
              "_impl#div#Prelude.Integral#Prelude.Int",
              "_impl#mod#Prelude.Integral#Prelude.Int",
              "_impl#quot#Prelude.Integral#Prelude.Int",
              "_inst#Prelude.Integral#Prelude.Int",
              "_super#Prelude.Integral#Prelude.Real",
              "abs",
              "div",
              "fromFloat",
              "rem",
              "signum",
              "mod",
              "quot"]

preludeList :: [String]
preludeList = ["_impl#/=#Prelude.Eq#[]",
               "_impl#<#Prelude.Ord#[]",
               "_impl#<=#Prelude.Ord#[]",
               "_impl#==#Prelude.Eq#[]",
               "_impl#>#Prelude.Ord#[]",
               "_impl#>=#Prelude.Ord#[]",
               "_inst#Prelude.Eq#[]",
               "_inst#Prelude.Ord#[]",
               "_impl#max#Prelude.Ord#[]",
               "_impl#min#Prelude.Ord#[]",
               "_impl#compare#Prelude.Ord#[]",
               "_def#enumFrom#Prelude.Enum",
               "_def#enumFromThen#Prelude.Enum",
               "_def#enumFromThenTo#Prelude.Enum",
               "_def#enumFromTo#Prelude.Enum",
               "_def#fromEnum#Prelude.Enum",
               "_def#pred#Prelude.Enum",
               "_def#pred#Prelude.Enum._#lambda182",
               "_def#succ#Prelude.Enum",
               "_def#toEnum#Prelude.Enum",
               "_impl#enumFrom#Prelude.Enum#Prelude.Bool",
               "_impl#enumFrom#Prelude.Enum#Prelude.Char",
               "_impl#enumFrom#Prelude.Enum#Prelude.Int",
               "_impl#enumFrom#Prelude.Enum#Prelude.Ordering",
               "_impl#enumFromThen#Prelude.Enum#Prelude.Bool",
               "_impl#enumFromThen#Prelude.Enum#Prelude.Char",
               "_impl#enumFromThen#Prelude.Enum#Prelude.Int",
               "_impl#enumFromThen#Prelude.Enum#Prelude.Ordering",
               "_impl#enumFromThenTo#Prelude.Enum#Prelude.Bool",
               "_impl#enumFromThenTo#Prelude.Enum#Prelude.Char",
               "_impl#enumFromThenTo#Prelude.Enum#Prelude.Int",
               "_impl#enumFromThenTo#Prelude.Enum#Prelude.Ordering",
               "_impl#enumFromTo#Prelude.Enum#Prelude.Bool",
               "_impl#enumFromTo#Prelude.Enum#Prelude.Char",
               "_impl#enumFromTo#Prelude.Enum#Prelude.Int",
               "_impl#enumFromTo#Prelude.Enum#Prelude.Ordering",
               "_impl#fromEnum#Prelude.Enum#Prelude.Bool",
               "_impl#fromEnum#Prelude.Enum#Prelude.Char",
               "_impl#fromEnum#Prelude.Enum#Prelude.Int",
               "_impl#fromEnum#Prelude.Enum#Prelude.Ordering",
               "_impl#pred#Prelude.Enum#Prelude.Bool",
               "_impl#pred#Prelude.Enum#Prelude.Char",
               "_impl#pred#Prelude.Enum#Prelude.Int",
               "_impl#pred#Prelude.Enum#Prelude.Ordering",
               "_impl#succ#Prelude.Enum#Prelude.Bool",
               "_impl#succ#Prelude.Enum#Prelude.Char",
               "_impl#succ#Prelude.Enum#Prelude.Int",
               "_impl#succ#Prelude.Enum#Prelude.Ordering",
               "_impl#toEnum#Prelude.Enum#Prelude.Bool",
               "_impl#toEnum#Prelude.Enum#Prelude.Char",
               "_impl#toEnum#Prelude.Enum#Prelude.Int",
               "_impl#toEnum#Prelude.Enum#Prelude.Ordering",
               "_inst#Prelude.Enum#Prelude.Bool",
               "_inst#Prelude.Enum#Prelude.Char",
               "_inst#Prelude.Enum#Prelude.Int",
               "_inst#Prelude.Enum#Prelude.Ordering",
               "_def#maxBound#Prelude.Bounded",
               "_def#minBound#Prelude.Bounded",
               "_impl#maxBound#Prelude.Bounded#Prelude.Bool",
               "_impl#maxBound#Prelude.Bounded#Prelude.Char",
               "_impl#maxBound#Prelude.Bounded#Prelude.Ordering",
               "_impl#minBound#Prelude.Bounded#Prelude.Bool",
               "_impl#minBound#Prelude.Bounded#Prelude.Char",
               "_impl#minBound#Prelude.Bounded#Prelude.Ordering",
               "_inst#Prelude.Bounded#Prelude.Bool",
               "_inst#Prelude.Bounded#Prelude.Char",
               "_inst#Prelude.Bounded#Prelude.Ordering",
               "uppermostCharacter",
               "!!",
               "++",
               "append_build",
               "all",
               "and",
               "any",
               "anyOf",
               "boundedEnumFrom",
               "boundedEnumFromThen",
               "break",
               "concat",
               "concat_mkc", 
               "concatMap",
               "drop",
               "dropWhile",
               "elem",
               "enumFrom",
               "enumFromThen",
               "enumFromThenTo",
               "enumFromThenTo_",
               "enumFromThenTo_build",
               "enumFromThen_",
               "enumFromTo",
               "enumFromTo_",
               "enumFromTo_build",
               "enumFrom_",
               "filter",
               "filter_mkc", 
               "foldl",
               "foldl1",
               "foldr1",
               "fromEnum",
               "iterate", 
               "iterate_build", 
               "length", 
               "length_fold", 
               "lookup", 
               "lookup_fold", 
               "map",
               "map_mkc", 
               "maxBound",
               "minBound",
               "notElem",
               "null",
               "null_fold",
               "or",
               "pred",
               "repeat",
               "repeat_build", 
               "replicate",
               "reverse",
               "span",
               "splitAt",
               "succ",
               "take",
               "takeWhile",
               "toEnum"]

preludeString :: [String]
preludeString = ["_def#show#Prelude.Show",
                 "_def#showList#Prelude.Show",
                 "_def#showsPrec#Prelude.Show",
                 "_impl#showList#Prelude.Show#Prelude.Bool",
                 "_impl#showList#Prelude.Show#Prelude.Char",
                 "_impl#showList#Prelude.Show#Prelude.Either",
                 "_impl#showList#Prelude.Show#Prelude.Float",
                 "_impl#showList#Prelude.Show#Prelude.Int",
                 "_impl#showList#Prelude.Show#[]",
                 "_impl#showList#Prelude.Show#Prelude.Maybe",
                 "_impl#showList#Prelude.Show#Prelude.Ordering",
                 "_impl#showsPrec#Prelude.Show#Prelude.Bool",
                 "_impl#showsPrec#Prelude.Show#Prelude.Char",
                 "_impl#showsPrec#Prelude.Show#Prelude.Either",
                 "_impl#showsPrec#Prelude.Show#Prelude.Float",
                 "_impl#showsPrec#Prelude.Show#Prelude.Int",
                 "_inst#Prelude.Show#Prelude.Char",
                 "_impl#showsPrec#Prelude.Show#Prelude.Maybe",
                 "_impl#showsPrec#Prelude.Show#[]",
                 "_impl#showsPrec#Prelude.Show#Prelude.Ordering",
                 "prim_show",
                 "show_",
                 "getChar",
                 "isAlpha",
                 "isAlphaNum",
                 "isBinDigit",
                 "isDigit",
                 "isHexDigit",
                 "nonNull",
                 "nonNull._#lambda452",
                 "isLower",
                 "isOctDigit",
                 "isSpace",
                 "isUpper",
                 "lexLitChar",
                 "lexLitChar_lexEsc",
                 "lexLitChar_runEsc",
                 "lexLitChar_runEsc_1",
                 "lexLitChar_runEsc_2",
                 "lexLitChar_runEsc_3",
                 "lexLitChar_runEsc_4",
                 "lexLitChar_runEsc_5",
                 "lexLitChar_runEsc_6",
                 "lexLitChar_isAt",
                 "lexLitChar_isCharName",
                 "lexLitChar_lexPrefix",
                 "lex",
                 "lex_lexSingleQuote",
                 "lex_filterSingleQuote",
                 "lex_lexDoubleQuote",
                 "lex_else",
                 "lex_else_frac",
                 "lex_isSingle",
                 "lex_isSym",
                 "lex_isIdChar",
                 "lex_lexFracExp",
                 "lex_lexFracExp_dot",
                 "lex_lexFracExp_exp",
                 "makeTriple",
                 "lex_lexExp",
                 "lex_lexPMExp",
                 "lex_lexPMExp_sgn",
                 "lex_lexString",
                 "lex_lexString_build",
                 "lex_lexString_string",
                 "lex_lexStrItem",
                 "lexDigits",
                 "lines",
                 "splitline",
                 "show",
                 "showChar",
                 "showError",
                 "showList",
                 "showList'",
                 "showList'.showl.429",
                 "showParen",
                 "showSigned",
                 "showString",
                 "shows",
                 "showsPrec",
                 "unlines",
                 "unwords",
                 "unwords._#lambda282",
                 "words",
                 "_impl#show#Prelude.Show#[]",
                 "_inst#Prelude.Show#Prelude.Bool",
                 "_inst#Prelude.Show#Prelude.Either",
                 "_inst#Prelude.Show#Prelude.Float",
                 "_inst#Prelude.Show#[]",
                 "_inst#Prelude.Show#Prelude.Int",
                 "_inst#Prelude.Show#Prelude.Maybe",
                 "_inst#Prelude.Show#Prelude.Ordering",
                 "_impl#show#Prelude.Show#Prelude.Int",
                 "_impl#show#Prelude.Show#Prelude.Bool",
                 "_impl#show#Prelude.Show#Prelude.Char",
                 "_impl#show#Prelude.Show#Prelude.Either",
                 "_impl#show#Prelude.Show#Prelude.Float",
                 "_impl#show#Prelude.Show#Prelude.Maybe",
                 "_impl#show#Prelude.Show#Prelude.Ordering"]

preludeRead :: [String]
preludeRead = ["_def#readList#Prelude.Read",
               "_def#readsPrec#Prelude.Read",
               "_impl#readList#Prelude.Read#Prelude.Bool",
               "_impl#readList#Prelude.Read#Prelude.Char._#lambda41",
               "_impl#readList#Prelude.Read#Prelude.Char._#lambda41._#lambda44._#lambda48",
               "_impl#readList#Prelude.Read#Prelude.Char._#lambda41._#lambda44",
               "_impl#readList#Prelude.Read#Prelude.Either",
               "_impl#readList#Prelude.Read#Prelude.Float",
               "_impl#readList#Prelude.Read#Prelude.Maybe",
               "_impl#readList#Prelude.Read#Prelude.Ordering",
               "_impl#readsPrec#Prelude.Read#Prelude.Bool",
               "readTrue",
               "readFalse",
               "_impl#readsPrec#Prelude.Read#Prelude.Char",
               "_impl#readsPrec#Prelude.Read#Prelude.Char._#lambda32",
               "_impl#readsPrec#Prelude.Read#Prelude.Char._#lambda32._#lambda35",
               "_impl#readsPrec#Prelude.Read#Prelude.Char._#lambda32._#lambda35._#lambda39",
               "_impl#readsPrec#Prelude.Read#Prelude.Either",
               "readLeft",
               "makeLeft",
               "readRight",
               "makeRight",
               "_impl#readsPrec#Prelude.Read#Prelude.Maybe",
               "readNothing",
               "readJust",
               "makeJust",
               "_impl#readsPrec#Prelude.Read#Prelude.Float",
               "_impl#readsPrec#Prelude.Read#Prelude.Float._#lambda23",
               "_impl#readsPrec#Prelude.Read#Prelude.Float._#lambda23._#lambda26",
               "_impl#readsPrec#Prelude.Read#Prelude.Float._#lambda23._#lambda26._#lambda30",
               "_impl#readsPrec#Prelude.Read#Prelude.Float.readFloat.903",
               "_impl#readsPrec#Prelude.Read#Prelude.Float.readFloat.903._#lambda21",
               "_impl#readsPrec#Prelude.Read#Prelude.Int",
               "_impl#readsPrec#Prelude.Read#Prelude.Int._#lambda10",
               "_impl#readsPrec#Prelude.Read#Prelude.Int._#lambda10._#lambda13",
               "_impl#readsPrec#Prelude.Read#Prelude.Int._#lambda10._#lambda13._#lambda17",
               "_impl#readsPrec#Prelude.Read#[]",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda196",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda201",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda206",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda206._#lambda209",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda201._#lambda204",
               "_impl#readsPrec#Prelude.Read#Prelude.Ordering._#lambda196._#lambda199",
               "readLT",
               "readEQ",
               "readGT",
               "_inst#Prelude.Read#Prelude.Bool",
               "_inst#Prelude.Read#Prelude.Char",
               "_inst#Prelude.Read#Prelude.Either",
               "_inst#Prelude.Read#Prelude.Float",
               "_inst#Prelude.Read#Prelude.Int",
               "_inst#Prelude.Read#Prelude.Maybe",
               "_inst#Prelude.Read#Prelude.Ordering",
               "_inst#Prelude.Read#[]",
               "read",
               "read._#lambda346",
               "read._#lambda346._#lambda350",
               "readCharLiteral",
               "readDotNat",
               "readDotNat1",
               "readENat",
               "readFloatLiteral",
               "readList",
               "readListDefault",
               "readListDefault._#lambda326",
               "readListDefault._#lambda326._#lambda329",
               "readListDefault._#lambda326._#lambda329._#lambda331",
               "readListDefault.readl'.452",
               "readListDefault.readl'.452._#lambda312",
               "readListDefault.readl'.452._#lambda316._#lambda320",
               "readListDefault.readl'.452._#lambda316._#lambda320._#lambda324",
               "readListDefault.readl.452",
               "readListDefault.readl.452._#lambda300",
               "readListDefault.readl.452._#lambda304",
               "readListDefault.readl.452._#lambda304._#lambda308",
               "readNat",
               "readNatLiteral",
               "readParen",
               "readParen.mandatory.470",
               "readParen.mandatory.470._#lambda334._#lambda338",
               "readParen.mandatory.470._#lambda334._#lambda338._#lambda342",
               "readParen.optional.470",
               "readPosFloat",
               "readSigned",
               "readSigned.read''.490",
               "readSigned.read''.490._#lambda363",
               "readSigned.read''.490._#lambda363._#lambda367",
               "readSigned.read'.490",
               "readSigned.read'.490._#lambda355",
               "readSigned.read'.490._#lambda355._#lambda359",
               "readStringLiteral",
               "reads",
               "readsPrec",
               "readListDefault.readl'.452._#lambda316",
               "readParen.mandatory.470._#lambda334",
               "_impl#readList#Prelude.Read#Prelude.Char",
               "_impl#readList#Prelude.Read#Prelude.Int",
               "_impl#readList#Prelude.Read#[]"]

preludeMonad :: [String]
preludeMonad = [">>",
                ">>$",
                ">>$._#lambda283",
                ">>=",
                ">>=$",
                "_def#>>#Prelude.Monad",
                "_def#>>#Prelude.Monad._#lambda183",
                "_def#>>=#Prelude.Monad",
                "_def#fail#Prelude.Monad",
                "_def#fmap#Prelude.Functor",
                "_def#return#Prelude.Monad",
                "_impl#>>#Prelude.Monad#Prelude.IO",
                "_impl#>>=#Prelude.Monad#Prelude.IO",
                "_impl#>>=#Prelude.Monad#Prelude.Maybe",
                "_impl#>>=#Prelude.Monad#[]",
                "_impl#>>=#Prelude.Monad#[]._#lambda184",
                "_impl#>>=#Prelude.Monad#[]._#lambda184._#lambda185",
                "_impl#fail#Prelude.Monad#Prelude.Maybe",
                "_impl#fail#Prelude.Monad#[]",
                "_impl#fmap#Prelude.Functor#[]",
                "_impl#return#Prelude.Monad#Prelude.IO",
                "_impl#return#Prelude.Monad#Prelude.Maybe",
                "_impl#return#Prelude.Monad#[]",
                "_inst#Prelude.Functor#[]",
                "_inst#Prelude.Monad#Prelude.IO",
                "_inst#Prelude.Monad#Prelude.Maybe",
                "_inst#Prelude.Monad#[]",
                "done",
                "doSolve",
                "either",
                "foldIO._#lambda296",
                "foldM._#lambda457",
                "forIO",
                "forIO_",
                "forM",
                "forM_",
                "getLine",
                "getLine._#lambda285._#lambda288",
                "ioError",
                "liftIO",
                "liftM",
                "liftM2",
                "liftM2._#lambda460",
                "liftM2._#lambda460._#lambda462",
                "mapIO",
                "mapIO_",
                "mapM",
                "mapM_",
                "maybe",
                "print",
                "putStr",
                "putStrLn",
                "return",
                "returnIO",
                "sequence",
                "sequence._#lambda454",
                "sequence._#lambda454._#lambda455",
                "sequence._#lambda454._#lambda455._#lambda456",
                "sequenceIO._#lambda292",
                "sequenceIO._#lambda292._#lambda294",
                "sequenceIO_",
                "sequence_",
                "unless",
                "unlessM",
                "when",
                "whenM",
                "getLine._#lambda285",
                "fmap",
                "fail",
                "foldIO",
                "foldM",
                "sequenceIO",
                "userError",
                "_impl#>>#Prelude.Monad#Prelude.Maybe",
                "_impl#>>#Prelude.Monad#[]",
                "_inst#Prelude.Eq#Prelude.IOError",
                "_impl#fail#Prelude.Monad#Prelude.IO",
                "_impl#/=#Prelude.Eq#Prelude.IOError",
                "_impl#==#Prelude.Eq#Prelude.IOError",
                "_impl#showsPrec#Prelude.Show#Prelude.IOError",
                "_impl#showList#Prelude.Show#Prelude.IOError",
                "_impl#show#Prelude.Show#Prelude.IOError",
                "_inst#Prelude.Show#Prelude.IOError",
                "_inst#Prelude.Read#Prelude.IOError",
                "_impl#readsPrec#Prelude.Read#Prelude.IOError",
                "readIOError",
                "makeIOError",
                "readUserError",
                "makeUserError",
                "readFailError",
                "makeFailError",
                "readNondetError",
                "makeNondetError",
                "_impl#readList#Prelude.Read#Prelude.IOError"]

preludeTuple :: [String]
preludeTuple = ["_impl#<=#Prelude.Ord#()",
                "_impl#<=#Prelude.Ord#(,)",
                "_impl#<=#Prelude.Ord#(,,)",
                "_impl#<=#Prelude.Ord#(,,,)",
                "_impl#<=#Prelude.Ord#(,,,,)",
                "_impl#==#Prelude.Eq#()",
                "_impl#==#Prelude.Eq#(,)",
                "_impl#==#Prelude.Eq#(,,)",
                "_impl#==#Prelude.Eq#(,,,)",
                "_impl#==#Prelude.Eq#(,,,,)",
                "_impl#==#Prelude.Eq#(,,,,,)",
                "_impl#==#Prelude.Eq#(,,,,,,)",
                "_impl#enumFrom#Prelude.Enum#()",
                "_impl#enumFromThen#Prelude.Enum#()",
                "_impl#enumFromThenTo#Prelude.Enum#()",
                "_impl#enumFromTo#Prelude.Enum#()",
                "_impl#fromEnum#Prelude.Enum#()",
                "_impl#max#Prelude.Ord#()",
                "_impl#max#Prelude.Ord#(,)",
                "_impl#max#Prelude.Ord#(,,)",
                "_impl#max#Prelude.Ord#(,,,)",
                "_impl#max#Prelude.Ord#(,,,,)",
                "_impl#maxBound#Prelude.Bounded#()",
                "_impl#maxBound#Prelude.Bounded#(,)",
                "_impl#maxBound#Prelude.Bounded#(,,)",
                "_impl#maxBound#Prelude.Bounded#(,,,)",
                "_impl#maxBound#Prelude.Bounded#(,,,,)",
                "_impl#minBound#Prelude.Bounded#()",
                "_impl#minBound#Prelude.Bounded#(,)",
                "_impl#minBound#Prelude.Bounded#(,,)",
                "_impl#minBound#Prelude.Bounded#(,,,)",
                "_impl#minBound#Prelude.Bounded#(,,,,)",
                "_impl#pred#Prelude.Enum#()",
                "_impl#readList#Prelude.Read#()",
                "_impl#readList#Prelude.Read#(,)",
                "_impl#readList#Prelude.Read#(,,)",
                "_impl#readList#Prelude.Read#(,,,)",
                "_impl#readList#Prelude.Read#(,,,,)",
                "_impl#readsPrec#Prelude.Read#()",
                "_impl#readsPrec#Prelude.Read#(,)",
                "_impl#readsPrec#Prelude.Read#(,,)",
                "_impl#readsPrec#Prelude.Read#(,,,)",
                "_impl#readsPrec#Prelude.Read#(,,,,)",
                "c2",
                "c3",
                "c4",
                "c5",
                "readsLParen",
                "readsVal_5",
                "readsComma_4",
                "readsVal_4",
                "readsComma_3",
                "readsVal_3",
                "readsComma_2",
                "readsVal_2",
                "readsComma_1",
                "readsVal_1",
                "readsRParen",
                "readsUnit",
                "_impl#showList#Prelude.Show#()", 
                "_impl#showList#Prelude.Show#(,)",
                "_impl#showList#Prelude.Show#(,,)",
                "_impl#showList#Prelude.Show#(,,,)",
                "_impl#showList#Prelude.Show#(,,,,)",
                "_impl#showList#Prelude.Show#(,,,,,)",
                "_impl#showList#Prelude.Show#(,,,,,,)",
                "_impl#showList#Prelude.Show#(,,,,,,,)",
                "_impl#showsPrec#Prelude.Show#()",
                "_impl#showsPrec#Prelude.Show#(,)",
                "_impl#showsPrec#Prelude.Show#(,,)",
                "_impl#showsPrec#Prelude.Show#(,,,)",
                "_impl#showsPrec#Prelude.Show#(,,,,)",
                "_impl#showsPrec#Prelude.Show#(,,,,,)",
                "_impl#showsPrec#Prelude.Show#(,,,,,,)",
                "_impl#showsPrec#Prelude.Show#(,,,,,,,)",
                "_impl#succ#Prelude.Enum#()",
                "_impl#toEnum#Prelude.Enum#()",
                "_inst#Prelude.Bounded#()",
                "_inst#Prelude.Bounded#(,)",
                "_inst#Prelude.Bounded#(,,)",
                "_inst#Prelude.Bounded#(,,,)",
                "_inst#Prelude.Bounded#(,,,,)",
                "_inst#Prelude.Enum#()",
                "_inst#Prelude.Eq#()",
                "_inst#Prelude.Eq#(,)",
                "_inst#Prelude.Eq#(,,)",
                "_inst#Prelude.Eq#(,,,)",
                "_inst#Prelude.Eq#(,,,,)",
                "_inst#Prelude.Eq#(,,,,,)",
                "_inst#Prelude.Eq#(,,,,,,)",
                "curry",
                "showTuple",
                "showTuple._#lambda297",
                "uncurry",
                "unzip",
                "unzip._#selFP10#xs",
                "unzip._#selFP11#ys",
                "unzip3",
                "unzip3._#selFP13#xs",
                "unzip3._#selFP14#ys",
                "unzip3._#selFP15#zs",
                "zip", 
                "zip_build", 
                "zip3",
                "zipWith", 
                "zipWith_build", 
                "zipWith3",
                "_impl#/=#Prelude.Eq#()",
                "_impl#/=#Prelude.Eq#(,)",
                "_impl#/=#Prelude.Eq#(,,)",
                "_impl#/=#Prelude.Eq#(,,,)",
                "_impl#/=#Prelude.Eq#(,,,,)",
                "_impl#/=#Prelude.Eq#(,,,,,)",
                "_impl#/=#Prelude.Eq#(,,,,,,)",
                "_impl#<#Prelude.Ord#()",
                "_impl#<#Prelude.Ord#(,)",
                "_impl#<#Prelude.Ord#(,,)",
                "_impl#<#Prelude.Ord#(,,,)",
                "_impl#<#Prelude.Ord#(,,,,)",
                "_impl#>#Prelude.Ord#()",
                "_impl#>#Prelude.Ord#(,)",
                "_impl#>#Prelude.Ord#(,,)",
                "_impl#>#Prelude.Ord#(,,,)",
                "_impl#>#Prelude.Ord#(,,,,)",
                "_impl#>=#Prelude.Ord#()",
                "_impl#>=#Prelude.Ord#(,)",
                "_impl#>=#Prelude.Ord#(,,)",
                "_impl#>=#Prelude.Ord#(,,,)",
                "_impl#>=#Prelude.Ord#(,,,,)",
                "_impl#compare#Prelude.Ord#()",
                "_impl#compare#Prelude.Ord#(,)",
                "_impl#compare#Prelude.Ord#(,,)",
                "_impl#compare#Prelude.Ord#(,,,)",
                "_impl#compare#Prelude.Ord#(,,,,)",
                "_impl#min#Prelude.Ord#()",
                "_impl#min#Prelude.Ord#(,)",
                "_impl#min#Prelude.Ord#(,,)",
                "_impl#min#Prelude.Ord#(,,,)",
                "_impl#min#Prelude.Ord#(,,,,)",
                "_impl#show#Prelude.Show#()",
                "_impl#show#Prelude.Show#(,)",
                "_impl#show#Prelude.Show#(,,)",
                "_impl#show#Prelude.Show#(,,,)",
                "_impl#show#Prelude.Show#(,,,,)",
                "_impl#show#Prelude.Show#(,,,,,)",
                "_impl#show#Prelude.Show#(,,,,,,)",
                "_impl#show#Prelude.Show#(,,,,,,,)",
                "_inst#Prelude.Ord#()",
                "_inst#Prelude.Ord#(,)",
                "_inst#Prelude.Ord#(,,)",
                "_inst#Prelude.Ord#(,,,)",
                "_inst#Prelude.Ord#(,,,,)",
                "_inst#Prelude.Read#()",
                "_inst#Prelude.Read#(,)",
                "_inst#Prelude.Read#(,,)",
                "_inst#Prelude.Read#(,,,)",
                "_inst#Prelude.Read#(,,,,)",
                "_inst#Prelude.Show#()",
                "_inst#Prelude.Show#(,)",
                "_inst#Prelude.Show#(,,)",
                "_inst#Prelude.Show#(,,,)",
                "_inst#Prelude.Show#(,,,,)",
                "_inst#Prelude.Show#(,,,,,)",
                "_inst#Prelude.Show#(,,,,,,)",
                "_inst#Prelude.Show#(,,,,,,,)"]
