
\section{nondet}

We want to prove that it's OK to avoid pushing some nodes onto the stack.
To do this we first need to identify which nodes we'll need to push, and which we can avoid.
We define a persisted trait of an expression called nondet.
The idea is if an expression is non-deterministic, then we make
An expression is \textit{nondet} if any of the following are true.

> e' ->^* e where e' is nondet
> e == e_1 ? e_2
> e == let v_1 = e_1  in e where e[v_1 -> e_1] is nondet
> e == let v_1 free   in e where e[v_1 -> FREE] is nondet
> e == e' :: t where e' is nondet
> e == FORWARD(e') where e' is nondet
> e == f (e_1 ... e_n)
>  where  e_f[x_1 -> e_1, ... x_n -> e_n] is nondet
> e == case  e' of 
>            C_1 ... -> e_1
>            ...
>            C_n ... -> e_n
>  where  e' is nondet or
>         e' ->^* C_i e_i1 ... e_ik and
>         e_i[x_i1 -> e_i1 ... x_ik -> e_ik] is nondet

Now we claim that ``We only need to push nondet nodes to the stack.''
We can rephrase that as ``if any node is not nondet, then we can avoid pushing it to the stack
with no change in the computed results.''
So, to continue we need to figure out which nodes are det.
We can do this simply by negating the previous definition.
An expression is det if, and only if, |e| is not already marked as nondet, and one of the following holds.

> e == EXEMPT
> e == l
> e == FREE
> e == e' :: t where e' is det
> e == C e_1 ... e_n
> e == f e_1 ... e_n where e_f[x_1 -> e_1 ... x_n -> e_n] is det
> e == let v_1 = e_1  in e where e[v_1 -> e_1] is det
> e == let v_1 free   in e where e[v_1 -> FREE] is det
> e == case  e' of 
>            C_1 ... -> e_1
>            ...
>            C_n ... -> e_n
>  where  e' is det and
>         e' ->^* C_i e_i1 ... e_ik and
>         e_i[x_i1 -> e_i1 ... x_ik -> e_ik] is det

It may seem odd that |C e_1 ... e_n| and |FREE| are both det,
but remember we only evaluate to head normal form.
It doesn't matter if any subexpression is non-deterministic if we never look at it.
If the case that evaluates |e| to |C ...|, then that particular case is deterministic.
Similarly for |FREE| expressions.  It just so happens that the next part of evaluating a
|FREE| expression in a case statement is to replace it with a choice expression,
and that expression will be nondet.
However, there's no need to push the |FREE| expression onto the stack as well.

Before we can prove our claim, we need to make one important note.\\
$\ $\\
\textbf{lemma:} for any expression |e|, if |e ->^* v| where |v| is a value, and |e| is det, then |e ->^* v| in every context.\\
$\ $\\
Note that this would not even be worth mentioning for a functional language,
Since we are in a combinator language, there are no free variables, and 
functional languages are confluent.
So every rewrite is deterministic.
However, it's absolutely not true for Curry.
Consider the expression: 
> main = let  x = True ? False
>             y = not x
>             z = not x
>             in eq y z
> 
> not b = case  b of
>               True   -> False
>               False  -> True
> eq y z = in case  y of 
>                   True   -> case  z of 
>                                   True   -> True
>                                   False  -> False
>                   False  -> case  z of 
>                                   True   -> False
>                                   False  -> True

The |main| expression should always return |True|.
When we evaluate the expression we first choose |True| for |x|,
then evaluate |eq|, which reduces |y| and |z| to |False|,
and then returns |True|.
However, 

\begin{mdframed}
\centerline{
  \xymatrix@@C=-2pt@@R=10pt@@C=5pt{
      & \llap{$eq$\,} \bullet \ar@@{-}@@/-6pt/[dl] \ar@@{-}@@/-6pt/[dr] & \\
      \llap{$not$\,} \bullet \ar@@{-}@@/-6pt/[dr] & &
        \llap{$not$\,} \bullet \ar@@{-}@@/-6pt/[dl] \\
      & \llap{$?$\,} \bullet \ar@@{-}@@/-6pt/[dl] \ar@@{-}@@/-6pt/[dr] &  \\
      True \bullet & & False \bullet \\
  }
}
\end{mdframed}

\begin{proof}
\end{proof}


> (code (EXEMPT))
> (code l)
> (code (e :: t))
> (code (C e_1 ... e_n))
> (code (FREE))
> (code (f e_1 ... e_n))
> (code (FORWARD e))
> (code (e_1 ? e_2))
> (code (let v_1 = e_1 in e))
> (code (case e of bs))





> hnf :: Stack -> Expr -> (Expr, Stack)
> hnf bt (code (EXEMPT))                 =  (EXEMPT, bt)
> hnf bt (code l)                        =  (l, bt)
> hnf bt (code (e :: t))                 =  hnf bt (code e)
> hnf bt (code (C e_1 ... e_n))          =  (C e_1 ... e_n, bt)
> hnf bt (code (FREE))                   =  (FREE, bt)
> hnf bt (code (f e_1 ... e_n))          =  let  v_1 ... v_n = vars f
>                                                e_f = body f
>                                                sigma = {v_1 -> e_1, ... v_n -> e_n}
>                                                (e_f',bt') = hnf bt (sigma e_f)
>                                           in   push e_f' bt'
> hnf bt (code (FORWARD e))              =  let  (e',bt') = hnf bt e
>                                           in   push (FORWARD e') bt'
> hnf bt (code (e_1 ? e_2))              =  let  (e_1',bt') = hnf bt e_1
>                                           in   pushChoice (FORWARD e_1') bt')
> hnf bt (code (let v_1 = e_1 in e))     =  let  sigma = {v_1 -> e_1}
>                                           in   hnf bt (sigma e)
> hnf bt (code (case e of bs))
>  | e == (code (FORWARD e'))              =  let  (e',bt') = (hnf bt (code (case e' of bs)))
>                                                  fwd = FORWARD e'
>                                             in   push (FORWARD e') bt'
>  | e == (code (FREE))                    =  let  {C_1 ... -> _, ...,  C_n ... -> _} = bs
>                                                  e_1 = C_1 FREE ... FREE
>                                                  ...
>                                                  e_n = C_n FREE ... FREE
>                                                  e := e_1 ? ... ? e_n
>                                             in   hnf bt (code (case e of bs))
>  | hnf e == ((code l),bt')               =  let  (l -> be) `elem` bs
>                                                  (e',bt') = hnf bt be
>                                             in   push e' bt'
>  | hnf e == (code (C e_1 ... e_n),bt')  =   let  (C v_1 ... v_n -> be) `elem` bs
>                                                  sigma = {v_1 -> e_1, ... v_n -> e_n}
>                                                  (e', bt') = hnf bt (sigma be)
>                                             in   push e' bt'
